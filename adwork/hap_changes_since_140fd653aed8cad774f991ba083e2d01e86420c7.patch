diff --git a/libavcodec/bsf/hapqa_extract.c b/libavcodec/bsf/hapqa_extract.c
index 5c49a4de22..92f4669344 100644
--- a/libavcodec/bsf/hapqa_extract.c
+++ b/libavcodec/bsf/hapqa_extract.c
@@ -53,6 +53,7 @@ static int hapqa_extract(AVBSFContext *bsf, AVPacket *pkt)
     GetByteContext gbc;
     int section_size;
     enum HapSectionType section_type;
+    int section_header = 0;
     int start_section_size;
     int target_packet_size = 0;
     int ret = 0;
@@ -62,7 +63,8 @@ static int hapqa_extract(AVBSFContext *bsf, AVPacket *pkt)
         return ret;
 
     bytestream2_init(&gbc, pkt->data, pkt->size);
-    ret = ff_hap_parse_section_header(&gbc, &section_size, &section_type);
+    ret = ff_hap_parse_section_header(&gbc, &section_size, &section_type,
+                                      &section_header);
     if (ret != 0)
         goto fail;
 
@@ -72,24 +74,26 @@ static int hapqa_extract(AVBSFContext *bsf, AVPacket *pkt)
         goto fail;
     }
 
-    start_section_size = 4;
+    start_section_size = section_header;
 
     bytestream2_seek(&gbc, start_section_size, SEEK_SET);/* go to start of the first texture */
 
-    ret = ff_hap_parse_section_header(&gbc, &section_size, &section_type);
+    ret = ff_hap_parse_section_header(&gbc, &section_size, &section_type,
+                                      &section_header);
     if (ret != 0)
         goto fail;
 
-    target_packet_size = section_size + 4;
+    target_packet_size = section_size + section_header;
 
     if (check_texture(ctx, section_type) == 0) { /* the texture is not the one to keep */
-        start_section_size += 4 + section_size;
+        start_section_size += section_header + section_size;
         bytestream2_seek(&gbc, start_section_size, SEEK_SET);/* go to start of the second texture */
-        ret = ff_hap_parse_section_header(&gbc, &section_size, &section_type);
+        ret = ff_hap_parse_section_header(&gbc, &section_size, &section_type,
+                                          &section_header);
         if (ret != 0)
             goto fail;
 
-        target_packet_size = section_size + 4;
+        target_packet_size = section_size + section_header;
 
         if (check_texture(ctx, section_type) == 0){ /* the second texture is not the one to keep */
             av_log(bsf, AV_LOG_ERROR, "No valid texture found.\n");
diff --git a/libavcodec/hap.c b/libavcodec/hap.c
index ac4032ce11..45263c57ee 100644
--- a/libavcodec/hap.c
+++ b/libavcodec/hap.c
@@ -51,13 +51,17 @@ int ff_hap_set_chunk_count(HapContext *ctx, int count, int first_in_frame)
 av_cold void ff_hap_free_context(HapContext *ctx)
 {
     av_freep(&ctx->tex_buf);
+    av_freep(&ctx->tex_buf_alpha);
     av_freep(&ctx->chunks);
     av_freep(&ctx->chunk_results);
 }
 
 int ff_hap_parse_section_header(GetByteContext *gbc, int *section_size,
-                                enum HapSectionType *section_type)
+                                enum HapSectionType *section_type,
+                                int *section_header)
 {
+    int header_length;
+
     if (bytestream2_get_bytes_left(gbc) < 4)
         return AVERROR_INVALIDDATA;
 
@@ -69,8 +73,14 @@ int ff_hap_parse_section_header(GetByteContext *gbc, int *section_size,
             return AVERROR_INVALIDDATA;
 
         *section_size = bytestream2_get_le32(gbc);
+        header_length = 8;
+    } else {
+        header_length = 4;
     }
 
+    if (section_header)
+        *section_header = header_length;
+
     if (*section_size > bytestream2_get_bytes_left(gbc) || *section_size < 0)
         return AVERROR_INVALIDDATA;
     else
diff --git a/libavcodec/hap.h b/libavcodec/hap.h
index 1de6d45428..7819d0a6b0 100644
--- a/libavcodec/hap.h
+++ b/libavcodec/hap.h
@@ -34,6 +34,7 @@ enum HapTextureFormat {
     HAP_FMT_RGBADXT5  = 0x0E,
     HAP_FMT_YCOCGDXT5 = 0x0F,
     HAP_FMT_RGTC1     = 0x01,
+    HAP_FMT_HAPM      = 0x0D,  /* Multi-texture container format for HapM */
 };
 
 enum HapCompressor {
@@ -74,12 +75,16 @@ typedef struct HapContext {
     size_t tex_size;         /* Size of the compressed texture */
 
     size_t max_snappy;       /* Maximum compressed size for snappy buffer */
+    size_t max_snappy_alpha; /* Maximum compressed size for HapM alpha snappy buffer */
 
-    int texture_count;      /* 2 for HAQA, 1 for other version */
+    int texture_count;      /* 2 for HAPQA/HapM, 1 for other version */
     int texture_section_size; /* size of the part of the texture section (for HAPQA) */
 
-    TextureDSPThreadContext enc;
-    TextureDSPThreadContext dec[2];
+    uint8_t *tex_buf_alpha;  /* Buffer for alpha texture in HapM encoding */
+    size_t tex_size_alpha;   /* Size of alpha texture in HapM encoding */
+
+    TextureDSPThreadContext enc[2];  /* Encoder contexts for multi-texture */
+    TextureDSPThreadContext dec[2];  /* Decoder contexts for multi-texture */
 } HapContext;
 
 /*
@@ -98,6 +103,7 @@ av_cold void ff_hap_free_context(HapContext *ctx);
  * if the length is stored in the next long word. The fourth byte in the first
  * long word indicates the type of the current section. */
 int ff_hap_parse_section_header(GetByteContext *gbc, int *section_size,
-                                enum HapSectionType *section_type);
+                                enum HapSectionType *section_type,
+                                int *section_header);
 
 #endif /* AVCODEC_HAP_H */
diff --git a/libavcodec/hapdec.c b/libavcodec/hapdec.c
index 70bf592f2a..78961f4e12 100644
--- a/libavcodec/hapdec.c
+++ b/libavcodec/hapdec.c
@@ -54,7 +54,7 @@ static int hap_parse_decode_instructions(HapContext *ctx, int size)
 
     while (size > 0) {
         int stream_remaining = bytestream2_get_bytes_left(gbc);
-        ret = ff_hap_parse_section_header(gbc, &section_size, &section_type);
+        ret = ff_hap_parse_section_header(gbc, &section_size, &section_type, NULL);
         if (ret != 0)
             return ret;
 
@@ -128,7 +128,7 @@ static int hap_can_use_tex_in_place(HapContext *ctx)
     return 1;
 }
 
-static int hap_parse_frame_header(AVCodecContext *avctx)
+static int hap_parse_frame_header(AVCodecContext *avctx, int *section_header)
 {
     HapContext *ctx = avctx->priv_data;
     GetByteContext *gbc = &ctx->gbc;
@@ -137,7 +137,8 @@ static int hap_parse_frame_header(AVCodecContext *avctx)
     const char *compressorstr;
     int i, ret;
 
-    ret = ff_hap_parse_section_header(gbc, &ctx->texture_section_size, &section_type);
+    ret = ff_hap_parse_section_header(gbc, &ctx->texture_section_size, &section_type,
+                                      section_header);
     if (ret != 0)
         return ret;
 
@@ -168,7 +169,7 @@ static int hap_parse_frame_header(AVCodecContext *avctx)
             }
             break;
         case HAP_COMP_COMPLEX:
-            ret = ff_hap_parse_section_header(gbc, &section_size, &section_type);
+            ret = ff_hap_parse_section_header(gbc, &section_size, &section_type, NULL);
             if (ret == 0 && section_type != HAP_ST_DECODE_INSTRUCTIONS)
                 ret = AVERROR_INVALIDDATA;
             if (ret == 0)
@@ -256,19 +257,21 @@ static int hap_decode(AVCodecContext *avctx, AVFrame *frame,
     int section_size;
     enum HapSectionType section_type;
     int start_texture_section = 0;
+    int section_header_size = 0;
 
     bytestream2_init(&ctx->gbc, avpkt->data, avpkt->size);
 
     /* check for multi texture header */
     if (ctx->texture_count == 2) {
-        ret = ff_hap_parse_section_header(&ctx->gbc, &section_size, &section_type);
+        ret = ff_hap_parse_section_header(&ctx->gbc, &section_size, &section_type,
+                                          &section_header_size);
         if (ret != 0)
             return ret;
         if ((section_type & 0x0F) != 0x0D) {
             av_log(avctx, AV_LOG_ERROR, "Invalid section type in 2 textures mode %#04x.\n", section_type);
             return AVERROR_INVALIDDATA;
         }
-        start_texture_section = 4;
+        start_texture_section = section_header_size;
     }
 
     /* Get the output frame ready to receive data */
@@ -278,9 +281,10 @@ static int hap_decode(AVCodecContext *avctx, AVFrame *frame,
 
     for (t = 0; t < ctx->texture_count; t++) {
         bytestream2_seek(&ctx->gbc, start_texture_section, SEEK_SET);
+        section_header_size = 0;
 
         /* Check for section header */
-        ret = hap_parse_frame_header(avctx);
+        ret = hap_parse_frame_header(avctx, &section_header_size);
         if (ret < 0)
             return ret;
 
@@ -291,7 +295,7 @@ static int hap_decode(AVCodecContext *avctx, AVFrame *frame,
             return AVERROR_INVALIDDATA;
         }
 
-        start_texture_section += ctx->texture_section_size + 4;
+        start_texture_section += ctx->texture_section_size + section_header_size;
 
         /* Unpack the DXT texture */
         if (hap_can_use_tex_in_place(ctx)) {
diff --git a/libavcodec/hapenc.c b/libavcodec/hapenc.c
index a0b199906d..5267a7e893 100644
--- a/libavcodec/hapenc.c
+++ b/libavcodec/hapenc.c
@@ -24,7 +24,7 @@
  * @file
  * Hap encoder
  *
- * Fourcc: Hap1, Hap5, HapY
+ * Fourcc: Hap1, Hap5, HapY, HapA, HapM
  *
  * https://github.com/Vidvox/hap/blob/master/documentation/HapVideoDRAFT.md
  */
@@ -56,16 +56,47 @@ enum HapHeaderLength {
 static int compress_texture(AVCodecContext *avctx, uint8_t *out, int out_length, const AVFrame *f)
 {
     HapContext *ctx = avctx->priv_data;
-
-    if (ctx->tex_size > out_length)
-        return AVERROR_BUFFER_TOO_SMALL;
-
-    ctx->enc.tex_data.out = out;
-    ctx->enc.frame_data.in = f->data[0];
-    ctx->enc.stride = f->linesize[0];
-    ctx->enc.width  = avctx->width;
-    ctx->enc.height = avctx->height;
-    ff_texturedsp_exec_compress_threads(avctx, &ctx->enc);
+    int t;
+
+    if (ctx->texture_count == 2) {
+        /* HapM: encode two textures (DXT5-YCoCg + RGTC1 alpha) */
+        size_t tex_size_ycocg = avctx->width / TEXTURE_BLOCK_W *
+                                avctx->height / TEXTURE_BLOCK_H * ctx->enc[0].tex_ratio;
+        size_t tex_size_alpha = avctx->width / TEXTURE_BLOCK_W *
+                                avctx->height / TEXTURE_BLOCK_H * ctx->enc[1].tex_ratio;
+
+        if (tex_size_ycocg + tex_size_alpha > out_length)
+            return AVERROR_BUFFER_TOO_SMALL;
+
+        /* Encode DXT5-YCoCg texture (RGB data) */
+        ctx->enc[0].tex_data.out = out;
+        ctx->enc[0].frame_data.in = f->data[0];
+        ctx->enc[0].stride = f->linesize[0];
+        ctx->enc[0].width  = avctx->width;
+        ctx->enc[0].height = avctx->height;
+        ff_texturedsp_exec_compress_threads(avctx, &ctx->enc[0]);
+
+        /* Encode RGTC1 alpha texture */
+        ctx->enc[1].tex_data.out = out + tex_size_ycocg;
+        ctx->enc[1].frame_data.in = f->data[0];
+        ctx->enc[1].stride = f->linesize[0];
+        ctx->enc[1].width  = avctx->width;
+        ctx->enc[1].height = avctx->height;
+        ff_texturedsp_exec_compress_threads(avctx, &ctx->enc[1]);
+
+        ctx->tex_size_alpha = tex_size_alpha;
+    } else {
+        /* Single texture encoding */
+        if (ctx->tex_size > out_length)
+            return AVERROR_BUFFER_TOO_SMALL;
+
+        ctx->enc[0].tex_data.out = out;
+        ctx->enc[0].frame_data.in = f->data[0];
+        ctx->enc[0].stride = f->linesize[0];
+        ctx->enc[0].width  = avctx->width;
+        ctx->enc[0].height = avctx->height;
+        ff_texturedsp_exec_compress_threads(avctx, &ctx->enc[0]);
+    }
 
     return 0;
 }
@@ -136,13 +167,13 @@ static int hap_compress_frame(AVCodecContext *avctx, uint8_t *dst)
     return final_size;
 }
 
-static int hap_decode_instructions_length(HapContext *ctx)
+static int hap_decode_instructions_length(int chunk_count)
 {
     /*    Second-Stage Compressor Table (one byte per entry)
      *  + Chunk Size Table (four bytes per entry)
      *  + headers for both sections (short versions)
      *  = chunk_count + (4 * chunk_count) + 4 + 4 */
-    return (5 * ctx->chunk_count) + 8;
+    return (5 * chunk_count) + 8;
 }
 
 static int hap_header_length(HapContext *ctx)
@@ -150,41 +181,54 @@ static int hap_header_length(HapContext *ctx)
     /* Top section header (long version) */
     int length = HAP_HDR_LONG;
 
-    if (ctx->chunk_count > 1) {
+    if (ctx->texture_count == 1 && ctx->chunk_count > 1) {
         /* Decode Instructions header (short) + Decode Instructions Container */
-        length += HAP_HDR_SHORT + hap_decode_instructions_length(ctx);
+        length += HAP_HDR_SHORT + hap_decode_instructions_length(ctx->chunk_count);
     }
 
     return length;
 }
 
-static void hap_write_frame_header(HapContext *ctx, uint8_t *dst, int frame_length)
+static int hap_texture_section_header_length(int chunk_count)
+{
+    int length = HAP_HDR_LONG;
+
+    if (chunk_count > 1)
+        length += HAP_HDR_SHORT + hap_decode_instructions_length(chunk_count);
+
+    return length;
+}
+
+static void hap_write_texture_header(HapContext *ctx, uint8_t *dst,
+                                     enum HapTextureFormat tex_fmt,
+                                     int chunk_count, int frame_length)
 {
     PutByteContext pbc;
     int i;
 
     bytestream2_init_writer(&pbc, dst, frame_length);
-    if (ctx->chunk_count == 1) {
+
+    if (chunk_count == 1) {
         /* Write a simple header */
         hap_write_section_header(&pbc, HAP_HDR_LONG, frame_length - 8,
-                                 ctx->chunks[0].compressor | ctx->opt_tex_fmt);
+                                 ctx->chunks[0].compressor | tex_fmt);
     } else {
         /* Write a complex header with Decode Instructions Container */
         hap_write_section_header(&pbc, HAP_HDR_LONG, frame_length - 8,
-                                 HAP_COMP_COMPLEX | ctx->opt_tex_fmt);
-        hap_write_section_header(&pbc, HAP_HDR_SHORT, hap_decode_instructions_length(ctx),
+                                 HAP_COMP_COMPLEX | tex_fmt);
+        hap_write_section_header(&pbc, HAP_HDR_SHORT, hap_decode_instructions_length(chunk_count),
                                  HAP_ST_DECODE_INSTRUCTIONS);
-        hap_write_section_header(&pbc, HAP_HDR_SHORT, ctx->chunk_count,
+        hap_write_section_header(&pbc, HAP_HDR_SHORT, chunk_count,
                                  HAP_ST_COMPRESSOR_TABLE);
 
-        for (i = 0; i < ctx->chunk_count; i++) {
+        for (i = 0; i < chunk_count; i++) {
             bytestream2_put_byte(&pbc, ctx->chunks[i].compressor >> 4);
         }
 
-        hap_write_section_header(&pbc, HAP_HDR_SHORT, ctx->chunk_count * 4,
+        hap_write_section_header(&pbc, HAP_HDR_SHORT, chunk_count * 4,
                                  HAP_ST_SIZE_TABLE);
 
-        for (i = 0; i < ctx->chunk_count; i++) {
+        for (i = 0; i < chunk_count; i++) {
             bytestream2_put_le32(&pbc, ctx->chunks[i].compressed_size);
         }
     }
@@ -194,41 +238,127 @@ static int hap_encode(AVCodecContext *avctx, AVPacket *pkt,
                       const AVFrame *frame, int *got_packet)
 {
     HapContext *ctx = avctx->priv_data;
-    int header_length = hap_header_length(ctx);
-    int final_data_size, ret;
-    int pktsize = FFMAX(ctx->tex_size, ctx->max_snappy * ctx->chunk_count) + header_length;
+    int ret;
 
-    /* Allocate maximum size packet, shrink later. */
-    ret = ff_alloc_packet(avctx, pkt, pktsize);
-    if (ret < 0)
-        return ret;
+    if (ctx->texture_count == 1) {
+        int header_length = hap_header_length(ctx);
+        int final_data_size;
+        int pktsize = FFMAX(ctx->tex_size, ctx->max_snappy * ctx->chunk_count) + header_length;
 
-    if (ctx->opt_compressor == HAP_COMP_NONE) {
-        /* DXTC compression directly to the packet buffer. */
-        ret = compress_texture(avctx, pkt->data + header_length, pkt->size - header_length, frame);
+        /* Allocate maximum size packet, shrink later. */
+        ret = ff_alloc_packet(avctx, pkt, pktsize);
         if (ret < 0)
             return ret;
 
-        ctx->chunks[0].compressor = HAP_COMP_NONE;
-        final_data_size = ctx->tex_size;
+        if (ctx->opt_compressor == HAP_COMP_NONE) {
+            /* DXTC compression directly to the packet buffer. */
+            ret = compress_texture(avctx, pkt->data + header_length, pkt->size - header_length, frame);
+            if (ret < 0)
+                return ret;
+
+            ctx->chunks[0].compressor = HAP_COMP_NONE;
+            ctx->chunks[0].compressed_offset = 0;
+            ctx->chunks[0].compressed_size = ctx->tex_size;
+            final_data_size = ctx->tex_size;
+        } else {
+            /* DXTC compression. */
+            ret = compress_texture(avctx, ctx->tex_buf, ctx->tex_size, frame);
+            if (ret < 0)
+                return ret;
+
+            /* Compress (using Snappy) the frame */
+            final_data_size = hap_compress_frame(avctx, pkt->data + header_length);
+            if (final_data_size < 0)
+                return final_data_size;
+        }
+
+        /* Write header at the start. */
+        hap_write_texture_header(ctx, pkt->data, ctx->opt_tex_fmt, ctx->chunk_count,
+                                 final_data_size + header_length);
+
+        av_shrink_packet(pkt, final_data_size + header_length);
+        *got_packet = 1;
+        return 0;
     } else {
-        /* DXTC compression. */
-        ret = compress_texture(avctx, ctx->tex_buf, ctx->tex_size, frame);
+        int chunk_count = ctx->chunk_count;
+        int tex_header_len = hap_texture_section_header_length(chunk_count);
+        int top_header_len = HAP_HDR_LONG;
+        int max_payload[2];
+        int compressed_size[2];
+        int header_total = top_header_len + tex_header_len * ctx->texture_count;
+        int data_offset = header_total;
+        size_t tex_size_main = ctx->tex_size;
+        size_t tex_size_alpha = ctx->tex_size_alpha;
+        size_t max_snappy_main = ctx->max_snappy;
+        size_t max_snappy_alpha = ctx->max_snappy_alpha;
+        uint8_t *tex_buf_main = ctx->tex_buf;
+        PutByteContext pbc;
+        enum HapTextureFormat tex_formats[2] = { HAP_FMT_YCOCGDXT5, HAP_FMT_RGTC1 };
+
+        if (ctx->opt_compressor == HAP_COMP_SNAPPY) {
+            max_payload[0] = (int)(ctx->max_snappy * chunk_count);
+            max_payload[1] = (int)(ctx->max_snappy_alpha * chunk_count);
+        } else {
+            max_payload[0] = (int)ctx->tex_size;
+            max_payload[1] = (int)ctx->tex_size_alpha;
+        }
+
+        ret = ff_alloc_packet(avctx, pkt, header_total + max_payload[0] + max_payload[1]);
         if (ret < 0)
             return ret;
 
-        /* Compress (using Snappy) the frame */
-        final_data_size = hap_compress_frame(avctx, pkt->data + header_length);
-        if (final_data_size < 0)
-            return final_data_size;
-    }
+        for (int t = 0; t < ctx->texture_count; t++) {
+            TextureDSPThreadContext *enc = &ctx->enc[t];
+            uint8_t *texture_dst = pkt->data + data_offset;
+            size_t tex_size = t == 0 ? tex_size_main : tex_size_alpha;
+
+            enc->tex_data.out = (ctx->opt_compressor == HAP_COMP_NONE) ?
+                                texture_dst :
+                                (t == 0 ? tex_buf_main : ctx->tex_buf_alpha);
+            enc->frame_data.in = frame->data[0];
+            enc->stride = frame->linesize[0];
+            enc->width  = avctx->width;
+            enc->height = avctx->height;
+            ff_texturedsp_exec_compress_threads(avctx, enc);
+
+            if (ctx->opt_compressor == HAP_COMP_NONE) {
+                ctx->chunks[0].compressor = HAP_COMP_NONE;
+                ctx->chunks[0].compressed_offset = 0;
+                ctx->chunks[0].compressed_size = tex_size;
+                compressed_size[t] = (int)tex_size;
+            } else {
+                ctx->tex_size = tex_size;
+                ctx->max_snappy = t == 0 ? max_snappy_main : max_snappy_alpha;
+                ctx->tex_buf = (t == 0) ? tex_buf_main : ctx->tex_buf_alpha;
+
+                compressed_size[t] = hap_compress_frame(avctx, texture_dst);
+                if (compressed_size[t] < 0)
+                    return compressed_size[t];
+            }
+
+            hap_write_texture_header(ctx,
+                                     pkt->data + top_header_len + tex_header_len * t,
+                                     tex_formats[t],
+                                     chunk_count,
+                                     compressed_size[t] + tex_header_len);
+
+            data_offset += compressed_size[t];
+        }
 
-    /* Write header at the start. */
-    hap_write_frame_header(ctx, pkt->data, final_data_size + header_length);
+        ctx->tex_size = tex_size_main;
+        ctx->max_snappy = max_snappy_main;
+        ctx->tex_buf = tex_buf_main;
 
-    av_shrink_packet(pkt, final_data_size + header_length);
-    *got_packet = 1;
-    return 0;
+        bytestream2_init_writer(&pbc, pkt->data,
+                                header_total + compressed_size[0] + compressed_size[1]);
+        hap_write_section_header(&pbc, HAP_HDR_LONG,
+                                 header_total + compressed_size[0] + compressed_size[1] - top_header_len,
+                                 HAP_FMT_HAPM);
+
+        av_shrink_packet(pkt, header_total + compressed_size[0] + compressed_size[1]);
+        *got_packet = 1;
+        return 0;
+    }
 }
 
 static av_cold int hap_init(AVCodecContext *avctx)
@@ -236,6 +366,7 @@ static av_cold int hap_init(AVCodecContext *avctx)
     HapContext *ctx = avctx->priv_data;
     TextureDSPEncContext dxtc;
     int corrected_chunk_count;
+    int block_count;
     int ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);
 
     if (ret < 0) {
@@ -252,36 +383,62 @@ static av_cold int hap_init(AVCodecContext *avctx)
 
     ff_texturedspenc_init(&dxtc);
 
+    ctx->texture_count = 1;  /* Default to single texture */
+
     switch (ctx->opt_tex_fmt) {
     case HAP_FMT_RGBDXT1:
-        ctx->enc.tex_ratio = 8;
+        ctx->enc[0].tex_ratio = 8;
         avctx->codec_tag = MKTAG('H', 'a', 'p', '1');
         avctx->bits_per_coded_sample = 24;
-        ctx->enc.tex_funct = dxtc.dxt1_block;
+        ctx->enc[0].tex_funct = dxtc.dxt1_block;
         break;
     case HAP_FMT_RGBADXT5:
-        ctx->enc.tex_ratio = 16;
+        ctx->enc[0].tex_ratio = 16;
         avctx->codec_tag = MKTAG('H', 'a', 'p', '5');
         avctx->bits_per_coded_sample = 32;
-        ctx->enc.tex_funct = dxtc.dxt5_block;
+        ctx->enc[0].tex_funct = dxtc.dxt5_block;
         break;
     case HAP_FMT_YCOCGDXT5:
-        ctx->enc.tex_ratio = 16;
+        ctx->enc[0].tex_ratio = 16;
         avctx->codec_tag = MKTAG('H', 'a', 'p', 'Y');
         avctx->bits_per_coded_sample = 24;
-        ctx->enc.tex_funct = dxtc.dxt5ys_block;
+        ctx->enc[0].tex_funct = dxtc.dxt5ys_block;
+        break;
+    case HAP_FMT_RGTC1:
+        ctx->enc[0].tex_ratio = 8;
+        avctx->codec_tag = MKTAG('H', 'a', 'p', 'A');
+        avctx->bits_per_coded_sample = 8;
+        ctx->enc[0].tex_funct = dxtc.rgtc1u_gray_block;
+        break;
+    case HAP_FMT_HAPM:
+        /* HapM uses two textures: DXT5-YCoCg (16 bytes) + RGTC1 alpha (8 bytes) */
+        ctx->texture_count = 2;
+        ctx->enc[0].tex_ratio = 16;
+        ctx->enc[1].tex_ratio = 8;
+        avctx->codec_tag = MKTAG('H', 'a', 'p', 'M');
+        avctx->bits_per_coded_sample = 32;
+        ctx->enc[0].tex_funct = dxtc.dxt5ys_block;
+        ctx->enc[1].tex_funct = dxtc.rgtc1u_alpha_block;
+        ctx->enc[1].raw_ratio = 16;
+        ctx->enc[1].slice_count = av_clip(avctx->thread_count, 1, avctx->height / TEXTURE_BLOCK_H);
         break;
     default:
         av_log(avctx, AV_LOG_ERROR, "Invalid format %02X\n", ctx->opt_tex_fmt);
         return AVERROR_INVALIDDATA;
     }
-    ctx->enc.raw_ratio = 16;
-    ctx->enc.slice_count = av_clip(avctx->thread_count, 1, avctx->height / TEXTURE_BLOCK_H);
+    ctx->enc[0].raw_ratio = 16;
+    ctx->enc[0].slice_count = av_clip(avctx->thread_count, 1, avctx->height / TEXTURE_BLOCK_H);
+
+    block_count = (avctx->width  / TEXTURE_BLOCK_W) *
+                  (avctx->height / TEXTURE_BLOCK_H);
 
     /* Texture compression ratio is constant, so can we computer
      * beforehand the final size of the uncompressed buffer. */
-    ctx->tex_size   = avctx->width  / TEXTURE_BLOCK_W *
-                      avctx->height / TEXTURE_BLOCK_H * ctx->enc.tex_ratio;
+    ctx->tex_size = block_count * ctx->enc[0].tex_ratio;
+    if (ctx->texture_count == 2)
+        ctx->tex_size_alpha = block_count * ctx->enc[1].tex_ratio;
+    else
+        ctx->tex_size_alpha = 0;
 
     switch (ctx->opt_compressor) {
     case HAP_COMP_NONE:
@@ -289,12 +446,14 @@ static av_cold int hap_init(AVCodecContext *avctx)
         corrected_chunk_count = 1;
 
         ctx->max_snappy = ctx->tex_size;
+        ctx->max_snappy_alpha = ctx->tex_size_alpha;
         ctx->tex_buf = NULL;
+        ctx->tex_buf_alpha = NULL;
         break;
     case HAP_COMP_SNAPPY:
         /* Round the chunk count to divide evenly on DXT block edges */
         corrected_chunk_count = av_clip(ctx->opt_chunk_count, 1, HAP_MAX_CHUNKS);
-        while ((ctx->tex_size / ctx->enc.tex_ratio) % corrected_chunk_count != 0) {
+        while (block_count % corrected_chunk_count != 0) {
             corrected_chunk_count--;
         }
 
@@ -303,6 +462,14 @@ static av_cold int hap_init(AVCodecContext *avctx)
         if (!ctx->tex_buf) {
             return AVERROR(ENOMEM);
         }
+        if (ctx->texture_count == 2) {
+            ctx->max_snappy_alpha = snappy_max_compressed_length(ctx->tex_size_alpha / corrected_chunk_count);
+            ctx->tex_buf_alpha = av_malloc(ctx->tex_size_alpha);
+            if (!ctx->tex_buf_alpha) {
+                av_freep(&ctx->tex_buf);
+                return AVERROR(ENOMEM);
+            }
+        }
         break;
     default:
         av_log(avctx, AV_LOG_ERROR, "Invalid compressor %02X\n", ctx->opt_compressor);
@@ -331,10 +498,12 @@ static av_cold int hap_close(AVCodecContext *avctx)
 #define OFFSET(x) offsetof(HapContext, x)
 #define FLAGS     AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
-    { "format", NULL, OFFSET(opt_tex_fmt), AV_OPT_TYPE_INT, { .i64 = HAP_FMT_RGBDXT1 }, HAP_FMT_RGBDXT1, HAP_FMT_YCOCGDXT5, FLAGS, .unit = "format" },
+    { "format", NULL, OFFSET(opt_tex_fmt), AV_OPT_TYPE_INT, { .i64 = HAP_FMT_RGBDXT1 }, HAP_FMT_RGTC1, HAP_FMT_YCOCGDXT5, FLAGS, .unit = "format" },
         { "hap",       "Hap 1 (DXT1 textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_RGBDXT1   }, 0, 0, FLAGS, .unit = "format" },
         { "hap_alpha", "Hap Alpha (DXT5 textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_RGBADXT5  }, 0, 0, FLAGS, .unit = "format" },
         { "hap_q",     "Hap Q (DXT5-YCoCg textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_YCOCGDXT5 }, 0, 0, FLAGS, .unit = "format" },
+        { "hap_a",     "Hap Alpha-Only (RGTC1 textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_RGTC1 }, 0, 0, FLAGS, .unit = "format" },
+        { "hap_m",     "Hap M (DXT5-YCoCg + RGTC1 alpha)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_HAPM }, 0, 0, FLAGS, .unit = "format" },
     { "chunks", "chunk count", OFFSET(opt_chunk_count), AV_OPT_TYPE_INT, {.i64 = 1 }, 1, HAP_MAX_CHUNKS, FLAGS, },
     { "compressor", "second-stage compressor", OFFSET(opt_compressor), AV_OPT_TYPE_INT, { .i64 = HAP_COMP_SNAPPY }, HAP_COMP_NONE, HAP_COMP_SNAPPY, FLAGS, .unit = "compressor" },
         { "none",       "None", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_COMP_NONE }, 0, 0, FLAGS, .unit = "compressor" },
@@ -361,6 +530,6 @@ const FFCodec ff_hap_encoder = {
     .init           = hap_init,
     FF_CODEC_ENCODE_CB(hap_encode),
     .close          = hap_close,
-    CODEC_PIXFMTS(AV_PIX_FMT_RGBA),
+    CODEC_PIXFMTS(AV_PIX_FMT_RGBA, AV_PIX_FMT_GRAY8),
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavformat/isom_tags.c b/libavformat/isom_tags.c
index 151c42e9e6..2e944f21c1 100644
--- a/libavformat/isom_tags.c
+++ b/libavformat/isom_tags.c
@@ -253,6 +253,8 @@ const AVCodecTag ff_codec_movvideo_tags[] = {
     { AV_CODEC_ID_HAP, MKTAG('H', 'a', 'p', 'Y') },
     { AV_CODEC_ID_HAP, MKTAG('H', 'a', 'p', 'A') },
     { AV_CODEC_ID_HAP, MKTAG('H', 'a', 'p', 'M') },
+    { AV_CODEC_ID_HAP, MKTAG('H', 'a', 'p', '7') },
+    { AV_CODEC_ID_HAP, MKTAG('H', 'a', 'p', 'H') },
 
     { AV_CODEC_ID_DXV, MKTAG('D', 'X', 'D', '3') },
     { AV_CODEC_ID_DXV, MKTAG('D', 'X', 'D', 'I') },
