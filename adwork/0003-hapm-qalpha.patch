diff --git a/libavcodec/texturedsp.h b/libavcodec/texturedsp.h
index 43c36b27b4..36d6fcd6dc 100644
--- a/libavcodec/texturedsp.h
+++ b/libavcodec/texturedsp.h
@@ -65,6 +65,7 @@ typedef struct TextureDSPEncContext {
     int (*dxt5_block)        (uint8_t *dst, ptrdiff_t stride, const uint8_t *block);
     int (*dxt5ys_block)      (uint8_t *dst, ptrdiff_t stride, const uint8_t *block);
     int (*rgtc1u_gray_block) (uint8_t *dst, ptrdiff_t stride, const uint8_t *block);
+    int (*rgtc1u_alpha_block)(uint8_t *dst, ptrdiff_t stride, const uint8_t *block);
 } TextureDSPEncContext;

diff --git a/libavcodec/texturedspenc.c b/libavcodec/texturedspenc.c
index e5314f0101..59f00b0cb8 100644
--- a/libavcodec/texturedspenc.c
+++ b/libavcodec/texturedspenc.c
@@ -671,12 +671,29 @@ static int rgtc1u_gray_block(uint8_t *dst, ptrdiff_t stride, const uint8_t *bloc
     return 8;
 }
 
+/**
+ * Compress one block of alpha channel pixels in an RGTC1 texture (BC4) and store the
+ * resulting bytes in 'dst'. This extracts and compresses the alpha channel.
+ *
+ * @param dst    output buffer.
+ * @param stride scanline in bytes.
+ * @param block  block to compress.
+ * @return how much texture data has been written.
+ */
+static int rgtc1u_alpha_block(uint8_t *dst, ptrdiff_t stride, const uint8_t *block)
+{
+    compress_alpha(dst, stride, block);
+
+    return 8;
+}
+
 av_cold void ff_texturedspenc_init(TextureDSPEncContext *c)
 {
     c->dxt1_block         = dxt1_block;
     c->dxt5_block         = dxt5_block;
     c->dxt5ys_block       = dxt5ys_block;
     c->rgtc1u_gray_block  = rgtc1u_gray_block;
+    c->rgtc1u_alpha_block = rgtc1u_alpha_block;
 }
 
 #define TEXTUREDSP_FUNC_NAME ff_texturedsp_exec_compress_threads

diff --git a/libavcodec/hap.h b/libavcodec/hap.h
index 1de6d45428..7b45ae2de5 100644
--- a/libavcodec/hap.h
+++ b/libavcodec/hap.h
@@ -34,6 +34,7 @@ enum HapTextureFormat {
     HAP_FMT_RGBADXT5  = 0x0E,
     HAP_FMT_YCOCGDXT5 = 0x0F,
     HAP_FMT_RGTC1     = 0x01,
+    HAP_FMT_HAPM      = 0x0D,  /* Multi-texture container format for HapM */
 };
 
 enum HapCompressor {
@@ -74,11 +75,15 @@ typedef struct HapContext {
     size_t tex_size;         /* Size of the compressed texture */
 
     size_t max_snappy;       /* Maximum compressed size for snappy buffer */
+    size_t max_snappy_alpha; /* Maximum compressed size for HapM alpha snappy buffer */
 
-    int texture_count;      /* 2 for HAQA, 1 for other version */
+    int texture_count;      /* 2 for HAPQA/HapM, 1 for other version */
     int texture_section_size; /* size of the part of the texture section (for HAPQA) */
 
-    TextureDSPThreadContext enc;
+    uint8_t *tex_buf_alpha;  /* Buffer for alpha texture in HapM encoding */
+    size_t tex_size_alpha;   /* Size of alpha texture in HapM encoding */
+
+    TextureDSPThreadContext enc[2];  /* Encoder contexts for multi-texture */
     TextureDSPThreadContext dec[2];
 } HapContext;

diff --git a/libavcodec/hap.c b/libavcodec/hap.c
index ac4032ce11..5ac0bccf1d 100644
--- a/libavcodec/hap.c
+++ b/libavcodec/hap.c
@@ -51,6 +51,7 @@ int ff_hap_set_chunk_count(HapContext *ctx, int count, int first_in_frame)
 av_cold void ff_hap_free_context(HapContext *ctx)
 {
     av_freep(&ctx->tex_buf);
+    av_freep(&ctx->tex_buf_alpha);
     av_freep(&ctx->chunks);
     av_freep(&ctx->chunk_results);
 }

diff --git a/libavcodec/hapenc.c b/libavcodec/hapenc.c
index 7d89f1869b..1a2d1d8ee0 100644
--- a/libavcodec/hapenc.c
+++ b/libavcodec/hapenc.c
@@ -24,7 +24,7 @@
  * @file
  * Hap encoder
  *
- * Fourcc: Hap1, Hap5, HapY, HapA
+ * Fourcc: Hap1, Hap5, HapY, HapA, HapM
  *
  * https://github.com/Vidvox/hap/blob/master/documentation/HapVideoDRAFT.md
  */
@@ -56,16 +56,47 @@ enum HapHeaderLength {
 static int compress_texture(AVCodecContext *avctx, uint8_t *out, int out_length, const AVFrame *f)
 {
     HapContext *ctx = avctx->priv_data;
-
-    if (ctx->tex_size > out_length)
-        return AVERROR_BUFFER_TOO_SMALL;
-
-    ctx->enc.tex_data.out = out;
-    ctx->enc.frame_data.in = f->data[0];
-    ctx->enc.stride = f->linesize[0];
-    ctx->enc.width  = avctx->width;
-    ctx->enc.height = avctx->height;
-    ff_texturedsp_exec_compress_threads(avctx, &ctx->enc);
+    int t;
+
+    if (ctx->texture_count == 2) {
+        /* HapM: encode two textures (DXT5-YCoCg + RGTC1 alpha) */
+        size_t tex_size_ycocg = avctx->width / TEXTURE_BLOCK_W *
+                                avctx->height / TEXTURE_BLOCK_H * ctx->enc[0].tex_ratio;
+        size_t tex_size_alpha = avctx->width / TEXTURE_BLOCK_W *
+                                avctx->height / TEXTURE_BLOCK_H * ctx->enc[1].tex_ratio;
+
+        if (tex_size_ycocg + tex_size_alpha > out_length)
+            return AVERROR_BUFFER_TOO_SMALL;
+
+        /* Encode DXT5-YCoCg texture (RGB data) */
+        ctx->enc[0].tex_data.out = out;
+        ctx->enc[0].frame_data.in = f->data[0];
+        ctx->enc[0].stride = f->linesize[0];
+        ctx->enc[0].width  = avctx->width;
+        ctx->enc[0].height = avctx->height;
+        ff_texturedsp_exec_compress_threads(avctx, &ctx->enc[0]);
+
+        /* Encode RGTC1 alpha texture */
+        ctx->enc[1].tex_data.out = out + tex_size_ycocg;
+        ctx->enc[1].frame_data.in = f->data[0];
+        ctx->enc[1].stride = f->linesize[0];
+        ctx->enc[1].width  = avctx->width;
+        ctx->enc[1].height = avctx->height;
+        ff_texturedsp_exec_compress_threads(avctx, &ctx->enc[1]);
+
+        ctx->tex_size_alpha = tex_size_alpha;
+    } else {
+        /* Single texture encoding */
+        if (ctx->tex_size > out_length)
+            return AVERROR_BUFFER_TOO_SMALL;
+
+        ctx->enc[0].tex_data.out = out;
+        ctx->enc[0].frame_data.in = f->data[0];
+        ctx->enc[0].stride = f->linesize[0];
+        ctx->enc[0].width  = avctx->width;
+        ctx->enc[0].height = avctx->height;
+        ff_texturedsp_exec_compress_threads(avctx, &ctx->enc[0]);
+    }
 
     return 0;
 }
@@ -136,13 +167,13 @@ static int hap_compress_frame(AVCodecContext *avctx, uint8_t *dst)
     return final_size;
 }
 
-static int hap_decode_instructions_length(HapContext *ctx)
+static int hap_decode_instructions_length(int chunk_count)
 {
     /*    Second-Stage Compressor Table (one byte per entry)
      *  + Chunk Size Table (four bytes per entry)
      *  + headers for both sections (short versions)
      *  = chunk_count + (4 * chunk_count) + 4 + 4 */
-    return (5 * ctx->chunk_count) + 8;
+    return (5 * chunk_count) + 8;
 }
 
 static int hap_header_length(HapContext *ctx)
@@ -150,41 +181,56 @@ static int hap_header_length(HapContext *ctx)
     /* Top section header (long version) */
     int length = HAP_HDR_LONG;
 
-    if (ctx->chunk_count > 1) {
+    if (ctx->texture_count == 1 && ctx->chunk_count > 1) {
         /* Decode Instructions header (short) + Decode Instructions Container */
-        length += HAP_HDR_SHORT + hap_decode_instructions_length(ctx);
+        length += HAP_HDR_SHORT + hap_decode_instructions_length(ctx->chunk_count);
     }
 
     return length;
 }
 
-static void hap_write_frame_header(HapContext *ctx, uint8_t *dst, int frame_length)
+static int hap_texture_section_header_length(int chunk_count,
+                                             enum HapHeaderLength header_length)
+{
+    int length = header_length;
+
+    if (chunk_count > 1)
+        length += HAP_HDR_SHORT + hap_decode_instructions_length(chunk_count);
+
+    return length;
+}
+
+static void hap_write_texture_header(HapContext *ctx, uint8_t *dst,
+                                     enum HapTextureFormat tex_fmt,
+                                     int chunk_count, int frame_length,
+                                     enum HapHeaderLength header_length)
 {
     PutByteContext pbc;
     int i;
 
     bytestream2_init_writer(&pbc, dst, frame_length);
-    if (ctx->chunk_count == 1) {
+
+    if (chunk_count == 1) {
         /* Write a simple header */
-        hap_write_section_header(&pbc, HAP_HDR_LONG, frame_length - 8,
-                                 ctx->chunks[0].compressor | ctx->opt_tex_fmt);
+        hap_write_section_header(&pbc, header_length, frame_length - header_length,
+                                 ctx->chunks[0].compressor | tex_fmt);
     } else {
         /* Write a complex header with Decode Instructions Container */
-        hap_write_section_header(&pbc, HAP_HDR_LONG, frame_length - 8,
-                                 HAP_COMP_COMPLEX | ctx->opt_tex_fmt);
-        hap_write_section_header(&pbc, HAP_HDR_SHORT, hap_decode_instructions_length(ctx),
+        hap_write_section_header(&pbc, header_length, frame_length - header_length,
+                                 HAP_COMP_COMPLEX | tex_fmt);
+        hap_write_section_header(&pbc, HAP_HDR_SHORT, hap_decode_instructions_length(chunk_count),
                                  HAP_ST_DECODE_INSTRUCTIONS);
-        hap_write_section_header(&pbc, HAP_HDR_SHORT, ctx->chunk_count,
+        hap_write_section_header(&pbc, HAP_HDR_SHORT, chunk_count,
                                  HAP_ST_COMPRESSOR_TABLE);
 
-        for (i = 0; i < ctx->chunk_count; i++) {
+        for (i = 0; i < chunk_count; i++) {
             bytestream2_put_byte(&pbc, ctx->chunks[i].compressor >> 4);
         }
 
-        hap_write_section_header(&pbc, HAP_HDR_SHORT, ctx->chunk_count * 4,
+        hap_write_section_header(&pbc, HAP_HDR_SHORT, chunk_count * 4,
                                  HAP_ST_SIZE_TABLE);
 
-        for (i = 0; i < ctx->chunk_count; i++) {
+        for (i = 0; i < chunk_count; i++) {
             bytestream2_put_le32(&pbc, ctx->chunks[i].compressed_size);
         }
     }
@@ -194,41 +240,139 @@ static int hap_encode(AVCodecContext *avctx, AVPacket *pkt,
                       const AVFrame *frame, int *got_packet)
 {
     HapContext *ctx = avctx->priv_data;
-    int header_length = hap_header_length(ctx);
-    int final_data_size, ret;
-    int pktsize = FFMAX(ctx->tex_size, ctx->max_snappy * ctx->chunk_count) + header_length;
+    int ret;
 
-    /* Allocate maximum size packet, shrink later. */
-    ret = ff_alloc_packet(avctx, pkt, pktsize);
-    if (ret < 0)
-        return ret;
+    if (ctx->texture_count == 1) {
+        int header_length = hap_header_length(ctx);
+        int final_data_size;
+        int pktsize = FFMAX(ctx->tex_size, ctx->max_snappy * ctx->chunk_count) + header_length;
 
-    if (ctx->opt_compressor == HAP_COMP_NONE) {
-        /* DXTC compression directly to the packet buffer. */
-        ret = compress_texture(avctx, pkt->data + header_length, pkt->size - header_length, frame);
+        /* Allocate maximum size packet, shrink later. */
+        ret = ff_alloc_packet(avctx, pkt, pktsize);
         if (ret < 0)
             return ret;
 
-        ctx->chunks[0].compressor = HAP_COMP_NONE;
-        final_data_size = ctx->tex_size;
+        if (ctx->opt_compressor == HAP_COMP_NONE) {
+            /* DXTC compression directly to the packet buffer. */
+            ret = compress_texture(avctx, pkt->data + header_length, pkt->size - header_length, frame);
+            if (ret < 0)
+                return ret;
+
+            ctx->chunks[0].compressor = HAP_COMP_NONE;
+            ctx->chunks[0].compressed_offset = 0;
+            ctx->chunks[0].compressed_size = ctx->tex_size;
+            final_data_size = ctx->tex_size;
+        } else {
+            /* DXTC compression. */
+            ret = compress_texture(avctx, ctx->tex_buf, ctx->tex_size, frame);
+            if (ret < 0)
+                return ret;
+
+            /* Compress (using Snappy) the frame */
+            final_data_size = hap_compress_frame(avctx, pkt->data + header_length);
+            if (final_data_size < 0)
+                return final_data_size;
+        }
+
+        /* Write header at the start. */
+        hap_write_texture_header(ctx, pkt->data, ctx->opt_tex_fmt, ctx->chunk_count,
+                                 final_data_size + header_length, HAP_HDR_LONG);
+
+        av_shrink_packet(pkt, final_data_size + header_length);
+        *got_packet = 1;
+        return 0;
     } else {
-        /* DXTC compression. */
-        ret = compress_texture(avctx, ctx->tex_buf, ctx->tex_size, frame);
+        int chunk_count = ctx->chunk_count;
+        int tex_header_len = hap_texture_section_header_length(chunk_count, HAP_HDR_SHORT);
+        int top_header_len = HAP_HDR_SHORT;
+        int max_payload[2];
+        int compressed_size[2];
+        int header_total = top_header_len + tex_header_len * ctx->texture_count;
+        int offset = top_header_len;
+        size_t tex_size_main = ctx->tex_size;
+        size_t tex_size_alpha = ctx->tex_size_alpha;
+        size_t max_snappy_main = ctx->max_snappy;
+        size_t max_snappy_alpha = ctx->max_snappy_alpha;
+        uint8_t *tex_buf_main = ctx->tex_buf;
+        PutByteContext pbc;
+        enum HapTextureFormat tex_formats[2] = { HAP_FMT_YCOCGDXT5, HAP_FMT_RGTC1 };
+
+        if (ctx->opt_compressor == HAP_COMP_SNAPPY) {
+            max_payload[0] = (int)(ctx->max_snappy * chunk_count);
+            max_payload[1] = (int)(ctx->max_snappy_alpha * chunk_count);
+        } else {
+            max_payload[0] = (int)ctx->tex_size;
+            max_payload[1] = (int)ctx->tex_size_alpha;
+        }
+
+        ret = ff_alloc_packet(avctx, pkt, header_total + max_payload[0] + max_payload[1]);
         if (ret < 0)
             return ret;
 
-        /* Compress (using Snappy) the frame */
-        final_data_size = hap_compress_frame(avctx, pkt->data + header_length);
-        if (final_data_size < 0)
-            return final_data_size;
-    }
+        for (int t = 0; t < ctx->texture_count; t++) {
+            TextureDSPThreadContext *enc = &ctx->enc[t];
+            int header_offset = offset;
+            int data_offset = header_offset + tex_header_len;
+            uint8_t *texture_dst = pkt->data + data_offset;
+            size_t tex_size = t == 0 ? tex_size_main : tex_size_alpha;
+
+            enc->tex_data.out = (ctx->opt_compressor == HAP_COMP_NONE) ?
+                                texture_dst :
+                                (t == 0 ? tex_buf_main : ctx->tex_buf_alpha);
+            enc->frame_data.in = frame->data[0];
+            enc->stride = frame->linesize[0];
+            enc->width  = avctx->width;
+            enc->height = avctx->height;
+            ff_texturedsp_exec_compress_threads(avctx, enc);
+
+            if (ctx->opt_compressor == HAP_COMP_NONE) {
+                ctx->chunks[0].compressor = HAP_COMP_NONE;
+                ctx->chunks[0].compressed_offset = 0;
+                ctx->chunks[0].compressed_size = tex_size;
+                compressed_size[t] = (int)tex_size;
+            } else {
+                ctx->tex_size = tex_size;
+                ctx->max_snappy = t == 0 ? max_snappy_main : max_snappy_alpha;
+                ctx->tex_buf = (t == 0) ? tex_buf_main : ctx->tex_buf_alpha;
+
+                compressed_size[t] = hap_compress_frame(avctx, texture_dst);
+                if (compressed_size[t] < 0)
+                    return compressed_size[t];
+            }
+
+            if ((size_t)compressed_size[t] > 0xFFFFFFU) {
+                av_log(avctx, AV_LOG_ERROR, "HapM texture section too large for short header.\n");
+                return AVERROR_INVALIDDATA;
+            }
+
+            hap_write_texture_header(ctx,
+                                     pkt->data + header_offset,
+                                     tex_formats[t],
+                                     chunk_count,
+                                     compressed_size[t] + tex_header_len,
+                                     HAP_HDR_SHORT);
+
+            offset = data_offset + compressed_size[t];
+        }
 
-    /* Write header at the start. */
-    hap_write_frame_header(ctx, pkt->data, final_data_size + header_length);
+        ctx->tex_size = tex_size_main;
+        ctx->max_snappy = max_snappy_main;
+        ctx->tex_buf = tex_buf_main;
 
-    av_shrink_packet(pkt, final_data_size + header_length);
-    *got_packet = 1;
-    return 0;
+        if ((size_t)offset - top_header_len > 0xFFFFFFU) {
+            av_log(avctx, AV_LOG_ERROR, "HapM frame too large for short header.\n");
+            return AVERROR_INVALIDDATA;
+        }
+
+        bytestream2_init_writer(&pbc, pkt->data, offset);
+        hap_write_section_header(&pbc, HAP_HDR_SHORT,
+                                 offset - top_header_len,
+                                 HAP_FMT_HAPM);
+
+        av_shrink_packet(pkt, offset);
+        *got_packet = 1;
+        return 0;
+    }
 }
 
 static av_cold int hap_init(AVCodecContext *avctx)
@@ -236,6 +380,7 @@ static av_cold int hap_init(AVCodecContext *avctx)
     HapContext *ctx = avctx->priv_data;
     TextureDSPEncContext dxtc;
     int corrected_chunk_count;
+    int block_count;
     int ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);
 
     if (ret < 0) {
@@ -252,42 +397,62 @@ static av_cold int hap_init(AVCodecContext *avctx)
 
     ff_texturedspenc_init(&dxtc);
 
+    ctx->texture_count = 1;  /* Default to single texture */
+
     switch (ctx->opt_tex_fmt) {
     case HAP_FMT_RGBDXT1:
-        ctx->enc.tex_ratio = 8;
+        ctx->enc[0].tex_ratio = 8;
         avctx->codec_tag = MKTAG('H', 'a', 'p', '1');
         avctx->bits_per_coded_sample = 24;
-        ctx->enc.tex_funct = dxtc.dxt1_block;
+        ctx->enc[0].tex_funct = dxtc.dxt1_block;
         break;
     case HAP_FMT_RGBADXT5:
-        ctx->enc.tex_ratio = 16;
+        ctx->enc[0].tex_ratio = 16;
         avctx->codec_tag = MKTAG('H', 'a', 'p', '5');
         avctx->bits_per_coded_sample = 32;
-        ctx->enc.tex_funct = dxtc.dxt5_block;
+        ctx->enc[0].tex_funct = dxtc.dxt5_block;
         break;
     case HAP_FMT_YCOCGDXT5:
-        ctx->enc.tex_ratio = 16;
+        ctx->enc[0].tex_ratio = 16;
         avctx->codec_tag = MKTAG('H', 'a', 'p', 'Y');
         avctx->bits_per_coded_sample = 24;
-        ctx->enc.tex_funct = dxtc.dxt5ys_block;
+        ctx->enc[0].tex_funct = dxtc.dxt5ys_block;
         break;
     case HAP_FMT_RGTC1:
-        ctx->enc.tex_ratio = 8;
+        ctx->enc[0].tex_ratio = 8;
         avctx->codec_tag = MKTAG('H', 'a', 'p', 'A');
         avctx->bits_per_coded_sample = 8;
-        ctx->enc.tex_funct = dxtc.rgtc1u_gray_block;
+        ctx->enc[0].tex_funct = dxtc.rgtc1u_gray_block;
+        break;
+    case HAP_FMT_HAPM:
+        /* HapM uses two textures: DXT5-YCoCg (16 bytes) + RGTC1 alpha (8 bytes) */
+        ctx->texture_count = 2;
+        ctx->enc[0].tex_ratio = 16;
+        ctx->enc[1].tex_ratio = 8;
+        avctx->codec_tag = MKTAG('H', 'a', 'p', 'M');
+        avctx->bits_per_coded_sample = 32;
+        ctx->enc[0].tex_funct = dxtc.dxt5ys_block;
+        ctx->enc[1].tex_funct = dxtc.rgtc1u_alpha_block;
+        ctx->enc[1].raw_ratio = 16;
+        ctx->enc[1].slice_count = av_clip(avctx->thread_count, 1, avctx->height / TEXTURE_BLOCK_H);
         break;
     default:
         av_log(avctx, AV_LOG_ERROR, "Invalid format %02X\n", ctx->opt_tex_fmt);
         return AVERROR_INVALIDDATA;
     }
-    ctx->enc.raw_ratio = 16;
-    ctx->enc.slice_count = av_clip(avctx->thread_count, 1, avctx->height / TEXTURE_BLOCK_H);
+    ctx->enc[0].raw_ratio = 16;
+    ctx->enc[0].slice_count = av_clip(avctx->thread_count, 1, avctx->height / TEXTURE_BLOCK_H);
+
+    block_count = (avctx->width  / TEXTURE_BLOCK_W) *
+                  (avctx->height / TEXTURE_BLOCK_H);
 
     /* Texture compression ratio is constant, so can we computer
      * beforehand the final size of the uncompressed buffer. */
-    ctx->tex_size   = avctx->width  / TEXTURE_BLOCK_W *
-                      avctx->height / TEXTURE_BLOCK_H * ctx->enc.tex_ratio;
+    ctx->tex_size = block_count * ctx->enc[0].tex_ratio;
+    if (ctx->texture_count == 2)
+        ctx->tex_size_alpha = block_count * ctx->enc[1].tex_ratio;
+    else
+        ctx->tex_size_alpha = 0;
 
     switch (ctx->opt_compressor) {
     case HAP_COMP_NONE:
@@ -295,12 +460,14 @@ static av_cold int hap_init(AVCodecContext *avctx)
         corrected_chunk_count = 1;
 
         ctx->max_snappy = ctx->tex_size;
+        ctx->max_snappy_alpha = ctx->tex_size_alpha;
         ctx->tex_buf = NULL;
+        ctx->tex_buf_alpha = NULL;
         break;
     case HAP_COMP_SNAPPY:
         /* Round the chunk count to divide evenly on DXT block edges */
         corrected_chunk_count = av_clip(ctx->opt_chunk_count, 1, HAP_MAX_CHUNKS);
-        while ((ctx->tex_size / ctx->enc.tex_ratio) % corrected_chunk_count != 0) {
+        while (block_count % corrected_chunk_count != 0) {
             corrected_chunk_count--;
         }
 
@@ -309,6 +476,14 @@ static av_cold int hap_init(AVCodecContext *avctx)
         if (!ctx->tex_buf) {
             return AVERROR(ENOMEM);
         }
+        if (ctx->texture_count == 2) {
+            ctx->max_snappy_alpha = snappy_max_compressed_length(ctx->tex_size_alpha / corrected_chunk_count);
+            ctx->tex_buf_alpha = av_malloc(ctx->tex_size_alpha);
+            if (!ctx->tex_buf_alpha) {
+                av_freep(&ctx->tex_buf);
+                return AVERROR(ENOMEM);
+            }
+        }
         break;
     default:
         av_log(avctx, AV_LOG_ERROR, "Invalid compressor %02X\n", ctx->opt_compressor);
@@ -342,6 +517,7 @@ static const AVOption options[] = {
         { "hap_alpha", "Hap Alpha (DXT5 textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_RGBADXT5  }, 0, 0, FLAGS, .unit = "format" },
         { "hap_q",     "Hap Q (DXT5-YCoCg textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_YCOCGDXT5 }, 0, 0, FLAGS, .unit = "format" },
         { "hap_a",     "Hap Alpha-Only (RGTC1 textures)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_RGTC1 }, 0, 0, FLAGS, .unit = "format" },
+        { "hap_m",     "Hap M (DXT5-YCoCg + RGTC1 alpha)", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_FMT_HAPM }, 0, 0, FLAGS, .unit = "format" },
     { "chunks", "chunk count", OFFSET(opt_chunk_count), AV_OPT_TYPE_INT, {.i64 = 1 }, 1, HAP_MAX_CHUNKS, FLAGS, },
     { "compressor", "second-stage compressor", OFFSET(opt_compressor), AV_OPT_TYPE_INT, { .i64 = HAP_COMP_SNAPPY }, HAP_COMP_NONE, HAP_COMP_SNAPPY, FLAGS, .unit = "compressor" },
         { "none",       "None", 0, AV_OPT_TYPE_CONST, { .i64 = HAP_COMP_NONE }, 0, 0, FLAGS, .unit = "compressor" },
